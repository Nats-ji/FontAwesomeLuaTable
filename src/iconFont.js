const fetch = require("node-fetch");
const YAML = require("yaml");
const utf8 = require("utf8");
const fs = require("fs");

const RepoUrl = "https://github.com/Nats-ji/IconFontCppHeadersAndLuaTables";

class iconGlyphs extends Array {
  fontAcronym;

  constructor(aAcronym) {
    super();
    this.fontAcronym = aAcronym;
  }

  addIcon(aName, aUnicode, aSearchStr) {
    this.push({
      id: aName,
      luaName: this.#formatLuaName(aName),
      luaLiteral: this.#formatLuaLiteral(aUnicode),
      cppName: this.#formatCppName(aName),
      cppLiteral: this.#formatCppLiteral(aUnicode),
      searchString: aSearchStr,
    });
  }

  #formatLuaName(aName) {
    const words = aName.replaceAll(" ", "-").replaceAll("_", "-").split("-");
    words.forEach((word, idx, arr) => {
      arr[idx] = word.charAt(0).toUpperCase() + word.slice(1);
    });
    let result = words.join("");

    // add _ prefix if name begin with a number
    if (!isNaN(result.charAt(0))) result = "_" + result;
    
    return result;
  }

  #formatCppName(aName) {
    const words = aName.replaceAll(" ", "-").replaceAll("_", "-").split("-");
    words.forEach((word, idx, arr) => {
      arr[idx] = arr[idx] = word.toUpperCase();
    });

    return "ICON_" + this.fontAcronym + "_" + words.join("_");
  }

  #formatLuaLiteral(aUnicode) {
    return `\\u{${aUnicode.toLowerCase()}}`;
  }

  #formatCppLiteral(aUnicode) {
    const utf8_encoded = utf8.encode(
      String.fromCodePoint(Number("0x" + aUnicode))
    );
    const result = escape(utf8_encoded).toLowerCase().replaceAll("%", "\\x");
    return result;
  }
}

class iconFont {
  name;
  acronym;
  outputFileName;
  metadataUrl;
  fontFileUrl;
  glyphRanges = {};

  icons;

  metadataFormat = "json";
  metadataRaw;

  async fetchMetaData() {
    const response = await fetch(this.metadataUrl);
    const data = await response.text();
    if (this.metadataFormat === "json") this.metadataRaw = JSON.parse(data);
    else if (this.metadataFormat === "yaml")
      this.metadataRaw = YAML.parse(data);
  }

  formatSearchString() {}
  sanitizeRawMetaData() {}

  dumpLuaTable() {
    let content = "";
    content += `-- Generated by ${RepoUrl} for LuaJLT and Lua 5.3+\n`;
    content += `-- from ${this.metadataUrl}\n`;
    content += `-- for use with ${this.fontFileUrl}\n`;
    content += "local IconGlyphs = {\n";
    for (const icon of this.icons) {
      content += `  ${icon.luaName} = "${icon.luaLiteral}",\t-- ${icon.searchString}\n`;
    }
    content += "}\n";
    content += "return IconGlyphs\n";
    return content;
  }

  dumpLuaType() {
    let content = "";
    content += `-- Generated by ${RepoUrl} for VSCode extension sumneko.lua\n`;
    content += `-- from ${this.metadataUrl}\n`;
    content += `-- for use with ${this.fontFileUrl}\n`;
    content += "---@meta\n";
    content += "---@diagnostic disable\n\n";
    content += "---@class IconGlyphs\n";
    for (const icon of this.icons) {
      content += `---@field ${icon.luaName} "${icon.luaLiteral}"\t${icon.searchString}\n`;
    }
    content += "IconGlyphs = {}\n";
    return content;
  }

  dumpCppHeader() {
    let content = "";
    content += `// Generated by ${RepoUrl} for C and C++\n`;
    content += `// from ${this.metadataUrl}\n`;
    content += `// for use with ${this.fontFileUrl}\n`;
    content += "#pragma once\n\n";

    // define ranges
    for (const rangeName in this.glyphRanges) {
      content += `#define ${
        "ICON_" + rangeName.toUpperCase() + "_" + this.acronym
      } ${this.glyphRanges[rangeName]}\n`;
    }

    // define glyphs
    for (const icon of this.icons) {
      content += `#define ${icon.cppName} "${icon.cppLiteral}"\t// ${icon.searchString}\n`;
    }
    return content;
  }

  async generateFile() {
    this.icons = new iconGlyphs(this.acronym);
    await this.fetchMetaData();
    this.sanitizeRawMetaData();

    fs.mkdirSync(this.outputFileName, { recursive: true });
    fs.writeFileSync(
      `${this.outputFileName}/${this.outputFileName}.lua`,
      this.dumpLuaTable()
    );
    fs.writeFileSync(
      `${this.outputFileName}/${this.outputFileName}.type.lua`,
      this.dumpLuaType()
    );
    fs.writeFileSync(
      `${this.outputFileName}/${this.outputFileName}.h`,
      this.dumpCppHeader()
    );
    console.log(`Generated files for ${this.name}.`);
  }
}

module.exports = iconFont;
